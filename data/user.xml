<templateSet group="user">
  <template name="req" value="let $param1$ = require('$param0$');" description="&quot;require a module&quot;" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="param0" expression="" defaultValue="$1" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="upper" value="tr '[:lower:]' '[:upper:]'" description="&quot;ensure Caps&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="twdebug" value="[ ! -z ${TWBASH_DEBUG+x} ] &amp;&amp; Cyan &quot;Sourcing $BASH_SOURCE&quot;" description="&quot;check TWBASH_DEBUG&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="twenv" value="# ${var+x} evaluates to nothing if var is unset, and substitutes the string x otherwise&#10;if [ -z ${var+x} ]; then echo &quot;var is unset&quot;; else echo &quot;var is set to '$var'&quot;; fi" description="&quot;check env var is set&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="suffix" value="filename=$(basename -- &quot;$fullfile&quot;)&#10;extension=&quot;${filename##*.}&quot;&#10;filename=&quot;${filename%.*}&quot;" description="&quot;get suffix&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="arr" value="$param1$=(&#10;&#09;&quot;foo&quot;&#10;&#09;&quot;bar&quot;&#10;)&#10;echo &quot;Array: ${$param0$[@]}&quot;&#10;echo &quot;Index: ${!$param0$[@]}&quot;&#10;echo &quot;Size: ${#$param0$[@]}&quot;&#10;for el in &quot;${$param0$[@]}&quot;; do&#10;&#09;echo $el&#10;done" description="&quot;array template&quot;" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="arr" alwaysStopAt="true" />
    <variable name="param0" expression="" defaultValue="$1" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="script" value="#!/usr/bin/env bash&#10;set +ex&#10;source ~/dev/binx/profile/sane_bash.sh&#10;&#10;TWBASH_DEBUG=true&#10;SCRIPT_DIR=&quot;$( cd &quot;$( dirname &quot;${BASH_SOURCE[0]}&quot; )&quot; &amp;&amp; pwd )&quot;&#10;START_TIME=$SECONDS&#10;&#10;echo &quot;-M- Start $(date)&quot;&#10;echo &quot;-M- End: $(($SECONDS - $START_TIME))&quot;&#10;exit 0" description="&quot;Script defaults&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="envrc.sh" value="#!/usr/bin/env bash&#10;&#10;source $HOME/dev/binx/profile/sane_bash.sh&#10;&#10;############### VENV ###############&#10;# Emulate the pipenvs's activate, because we can't source things in direnv&#10;#layout_pipenv&#10;#dotenv&#10;&#10;############### Exports ###############&#10;PROJ_DIR=&quot;$( cd &quot;$( dirname &quot;${BASH_SOURCE[0]}&quot; )&quot; &amp;&amp; pwd )&quot;&#10;export PROJ_DIR&#10;Green &quot;-M- exporting PROJ_DIR: $PROJ_DIR&quot;&#10;&#10;tmux rename-window $(basename $PROJ_DIR)&#10;&#10;export senv=&quot;source $PROJ_DIR/scripts/env.sh&quot;&#10;export PYTHONPATH=$PROJ_DIR&#10;&#10;PATH_add $PROJ_DIR/scripts&#10;&#10;############### Dotfile ###############&#10;DOTFILE_PYCHARM=&quot;.env.pycharm&quot;&#10;&gt;$DOTFILE_PYCHARM&#10;&#10;&#10;# create dotfile for pycharm (sanitized, no export)&#10;if [[ &quot;$OSTYPE&quot; == &quot;darwin&quot;* ]]; then&#10;&#09;DOTFILE_OS=&quot;.env.mac&quot;&#10;elif [[ &quot;$OSTYPE&quot; == &quot;linux-gnu&quot; ]]; then&#10;&#09;DOTFILE_OS=&quot;.env.linux&quot;&#10;fi&#10;if [[ -f &quot;$DOTFILE_OS&quot; ]]; then&#10;&#09;echo &quot;-M- sourcing $DOTFILE_OS&quot;&#10;&#09;#dotenv &quot;$DOTFILE_OS&quot;&#10;&#09;source &quot;$DOTFILE_OS&quot;&#10;&#09;cat &quot;$DOTFILE_OS&quot; | sed '/^echo/d' | sed '/^$/d' | sed 's/export //g' &gt;&gt; $DOTFILE_PYCHARM&#10;fi&#10;&#10;DOTFILE=&quot;.env.local&quot;&#10;if [[ -f &quot;$DOTFILE&quot; ]]; then&#10;&#09;echo &quot;-M- sourcing $DOTFILE&quot;&#10;&#09;#dotenv $DOTFILE  # enforces trigger after change&#10;&#09;source &quot;$DOTFILE&quot;&#10;&#09;cat &quot;$DOTFILE&quot; | sed '/^echo/d' | sed '/^$/d' | sed 's/export //g' &gt;&gt; $DOTFILE_PYCHARM&#10;fi&#10;&#10;DOTFILE=&quot;.env&quot;&#10;if [[ -f &quot;$DOTFILE&quot; ]]; then&#10;&#09;echo &quot;-M- sourcing $DOTFILE&quot;&#10;&#09;#dotenv $DOTFILE  # enforces trigger after change&#10;&#09;source &quot;$DOTFILE&quot;&#10;&#09;cat &quot;$DOTFILE&quot; | sed '/^echo/d' | sed '/^$/d' | sed 's/export //g' &gt;&gt; $DOTFILE_PYCHARM&#10;fi&#10;&#10;# make sure no confidential info gets into repo&#10;GITIGNORE='.gitignore'&#10;grep '.env$' &quot;$GITIGNORE&quot; &gt; /dev/null 2&gt;&amp;1&#10;[ $? -ne 0 ] &amp;&amp; echo &quot;.env&quot; &gt;&gt; &quot;$GITIGNORE&quot;&#10;#grep '.envrc$' &quot;$GITIGNORE&quot; &gt; /dev/null 2&gt;&amp;1&#10;#[ $? -ne 0 ] &amp;&amp; echo &quot;.envrc&quot; &gt;&gt; &quot;$GITIGNORE&quot;&#10;grep 'env.pycharm$' &quot;$GITIGNORE&quot; &gt; /dev/null 2&gt;&amp;1&#10;[ $? -ne 0 ] &amp;&amp; echo &quot;.env.pycharm&quot; &gt;&gt; &quot;$GITIGNORE&quot;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="yesno" value="# yes_or_no &quot;$message&quot; &amp;&amp; do_something&#10;function yes_or_no {&#10;&#09;while true; do&#10;&#09;&#09;read -p &quot;$* [y/n]: &quot; yn&#10;&#09;&#09;case $yn in&#10;&#09;&#09;&#09;[Yy]* ) return 0  ;;&#10;&#09;&#09;&#09;[Nn]* ) echo &quot;Aborted&quot; ; return 1 ;;&#10;&#09;&#09;&#09;* ) echo &quot;Please answer yes or no.&quot; ;;&#10;&#09;&#09;esac&#10;&#09;done&#10;}" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="continue" value="read -p &quot;Continue? (Y/N): &quot; confirm &amp;&amp; [[ $confirm == [yY] || $confirm == [yY][eE][sS] ]] || exit 1" description="&quot;continue interactive&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="input" value="read -p &quot;Enter: &quot; user" description="&quot;interactive input&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="new-window-complex" value="&#09;tmux new-window -c $HASS_DIR -n 'hass' &quot;bash --init-file &lt;(echo \&quot; \&#10;&#09;&#09;source $HOME/.profile; \&#10;&#09;&#09;source $HASS_DIR/scripts/hassio_funcs.sh; \&#10;&#09;&#09;echo \&quot;HA environment loaded\&quot; \&#10;&#09;&#09;\&quot;)&quot;" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="bashinteractive" value="bash --init-file &lt;(echo &quot;source \&quot;$HOME/.profile\&quot;; $param1$&quot;)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="cmd" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="here" value="# must not be indented, &quot;EOF&quot; to suppress variable expansion within&#10;read -r -d '' var &lt;&lt;EOF&#10;$param1$&#10;EOF&#10;echo &quot;$var&quot;" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="str" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="catch" value="exec 3&gt;&amp;2  # save stderr to fd3&#10;exec 2&gt; /dev/null&#10;$param1$&#10;exec 2&gt;&amp;3  # restore stderr" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="do stuff" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="script_path" value="#SCRIPT_DIR=&quot;$( cd &quot;$( dirname &quot;${BASH_SOURCE[0]}&quot; )&quot; &amp;&amp; pwd )&quot;&#10;SCRIPT_DIR=&quot;$(dirname ${BASH_SOURCE[0]})&quot;&#10;Cyan &quot;Sourcing ${BASH_SOURCE}&quot;" description="&quot;Get/sourcing script path&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="print" value="printf &quot;$param1$\n&quot; $param2$" description="&quot;print&quot;" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="format" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="args" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="func" value="$param1$ () {&#10;&#09;debug &quot;${FUNCNAME[0]}&quot;&#10;&#09;return 0&#10;}" description="&quot;Function Definition&quot;" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="name" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="getopts_func" value="$param1$ () {&#10;&#09;#foo&#10;&#09;#foo -a bc bar quux&#10;&#09;#foo -x&#10;&#10;&#09;foo_usage() { echo &quot;${FUNCNAME[0]}: [-a &lt;arg&gt;]&quot; 1&gt;&amp;2; exit; }&#10;&#10;&#09;local OPTIND opt a&#10;&#09;while getopts &quot;:a:&quot; opt; do&#10;&#09;&#09;case &quot;${opt}&quot; in&#10;&#09;&#09;&#09;a)&#10;&#09;&#09;&#09;&#09;a=&quot;${OPTARG}&quot;&#10;&#09;&#09;&#09;&#09;;;&#10;&#09;&#09;&#09;*)&#10;&#09;&#09;&#09;&#09;foo_usage&#10;&#09;&#09;&#09;&#09;return 1&#10;&#09;&#09;&#09;&#09;;;&#10;&#09;&#09;esac&#10;&#09;done&#10;&#09;shift $((OPTIND-1))&#10;&#10;&#09;echo &quot;a: [${a}], non-option arguments: $*&quot;&#10;&#09;return 0&#10;}" description="&quot;Function Definition with getopts&quot;" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="name" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="!#" value="#!/bin/bash" description="&quot;Hash Bang&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="case" value="case &quot;_parameter_to_change_&quot; in&#10;&#09;start)&#10;&#09;&#09;start&#10;&#09;&#09;;;&#10;&#09;stop)&#10;&#09;&#09;stop&#10;&#09;&#09;;;&#10;&#09;*)&#10;&#09;&#09;echo $&quot;Usage: _parameter_to_change_ {start|stop}&quot;&#10;&#09;&#09;exit 1&#10;esac" description="&quot;case&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="if" value="if list; then&#10;&#09;list&#10;elif&#10;&#09;list&#10;else&#10;&#09;list&#10;fi" description="&quot;if ... elif ... then&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="while" value="while $param2$ ]]}; do&#10;&#10;done" description="&quot;while&quot;" toReformat="true" toShortenFQNames="true">
    <variable name="param2" expression="" defaultValue="[[ ${1:condition} ]]" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="getopts_script" value="__ScriptVersion=&quot;version&quot;&#10;#export TWBASH_DEBUG=&quot;yes&quot;&#10;file=&quot;&quot;&#10;rflag=false&#10;sflag=false&#10;&#10;function usage () {&#10;&#09;echo &quot;Usage :   [options] [--]&#10;&#10;&#09;Options:&#10;&#09;-h:             Display this message&#10;&#09;-v:             Display script version&#10;&#09;-f filename:    Specifiy filename&#10;&#09;-r:             Run&#10;&#09;-s:             Stop&quot;&#10;}&#10;&#10;function x () {&#10;&#09;:&#10;}&#10;function y () {&#10;&#09;:&#10;}&#10;&#10;#------------------------------------- main -------------------------------------&#10;while getopts &quot;:hvf:&quot; opt&#10;do&#10;&#09;case $opt in&#10;&#09;&#09;h) usage; exit 0;;&#10;&#09;&#09;v) echo &quot; -- Version $__ScriptVersion&quot;; exit 0   ;;&#10;&#09;&#09;f) file=$OPTARG;;&#10;&#09;&#09;r) rflag=true; echo &quot;Starting Home-Assistant&quot;; x;;&#10;&#09;&#09;s) sflag=true; echo &quot;Stopping Home-Assistant&quot;; y;;&#10;&#09;&#09;*) echo -e &quot;\n  Option does not exist : $OPTARG\n&quot;&#10;&#09;&#09;&#09;usage; exit 1;;&#10;&#09;esac&#10;done&#10;&#10;shift $(($OPTIND-1))&#10;debug &quot;file: $file positional: $*&quot;&#10;&#10;# in case args need to be passed to function, collect first&#10;#$rflag &amp;&amp; x $file&#10;#$sflag &amp;&amp; y $file&#10;&#10;if ! $rflag &amp;&amp; ! $sflag; then&#10;&#09;usage&#10;&#09;exit 1&#10;fi" description="&quot;Getopts for script&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="-z" value="# Assert there is at least one tag provided&#10;test -z &quot;$_parameter_to_change_&quot; &amp;&amp; echo &quot;-E- tag required.&quot; 1&gt;&amp;2 &amp;&amp; exit 1" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="loop" value="for cmd in &quot;${Cmds[@]}&quot;; do&#10;&#09;echo &quot;$cmd&quot;&#10;done" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="test" value="$param1$ () {&#10;&#09;printf &quot;____Running $param1$\n&quot;&#10;&#09;ref=$param2$&#10;&#09;got=$($param3$)&#10;&#09;if [ &quot;$got&quot; == &quot;$ref&quot; ]; then&#10;&#09;&#09;Green &quot;Pass: $got&quot;&#10;&#09;else&#10;&#09;&#09;printf &quot;Expected: %s\n&quot; &quot;$ref&quot;&#10;&#09;&#09;printf &quot;Got: %s\n&quot; &quot;$got&quot;&#10;&#09;&#09;Red &quot;NOK&quot;&#10;&#09;fi&#10;&#09;return 0&#10;}" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="TestName" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="refVaue" alwaysStopAt="true" />
    <variable name="param3" expression="" defaultValue="gotValue" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="default_variable" value="default=&quot;$param1$&quot;&#10;$param1$=$\{$param1$:-$default\}" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="vname" alwaysStopAt="true" />
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="git-cmd" value="#!/usr/bin/env bash&#10;# based on https://github.com/tj/git-extras/tree/master/helper&#10;#&#10;# reset environment variables that could interfere with normal usage&#10;export GREP_OPTIONS=&#10;# put all utility functions here&#10;&#10;# make a temporary file&#10;git_extra_mktemp() {&#10;&#09;mktemp -t &quot;$(basename &quot;_parameter_to_change_&quot;)&quot;.XXXXXXX&#10;}&#10;&#10;git_extra_default_branch() {&#10;&#09;local default_branch&#10;&#09;default_branch=$(git config --get git-extras.default-branch)&#10;&#09;if [ -z &quot;$default_branch&quot; ]; then&#10;&#09;&#09;echo &quot;master&quot;&#10;&#09;else&#10;&#09;&#09;echo &quot;$default_branch&quot;&#10;&#09;fi&#10;}&#10;#&#10;# check whether current directory is inside a git repository&#10;#&#10;&#10;is_git_repo() {&#10;&#09;git rev-parse --show-toplevel &gt; /dev/null 2&gt;&amp;1&#10;&#09;result=$?&#10;&#09;if test $result != 0; then&#10;&#09;&#09;&gt;&amp;2 echo 'Not a git repo!'&#10;&#09;&#09;exit $result&#10;&#09;fi&#10;}&#10;&#10;#&#10;# check whether current directory contains any git commit&#10;#&#10;&#10;has_git_commit() {&#10;&#09;git rev-parse --short HEAD &gt; /dev/null 2&gt;&amp;1&#10;&#09;result=$?&#10;&#09;if test $result != 0; then&#10;&#09;&#09;&gt;&amp;2 echo 'Not git commit found!'&#10;&#09;&#09;exit $result&#10;&#09;fi&#10;}&#10;################################################################################&#10;# main&#10;################################################################################&#10;has_git_commit&#10;is_git_repo&#10;..." description="&quot;template for git command&quot;" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="SHELL_SCRIPT" value="true" />
      <option name="Bash" value="true" />
    </context>
  </template>
  <template name="echo" value="print(&quot;$param2$`!p snip.rv = echo_vals(t, '{}')`&quot;.format($param1$))" description="&quot;Python 3 echo&quot;" toReformat="true" toShortenFQNames="true">
    <variable name="param2" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="param1" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twfuncname" value="inspect.currentframe().f_code.co_name" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twprint" value="print(f&quot;\n{'$param1$':*^80}&quot;)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="msg" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="print_center" value="print('-' * 80)&#10;print('{:^80}'.format(&quot;$param1$&quot;))&#10;print('-' * 80)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="title" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="decorator" value="from functools import wraps&#10;&#10;&#10;def get_decorator(*args):&#10;&#09;def decorator(func):&#10;&#09;&#09;&quot;&quot;&quot; decorated fun points to the wrapper &quot;&quot;&quot;&#10;&#09;&#09;@wraps(func)&#10;&#09;&#09;def wrapper(*a, **kw):&#10;&#09;&#09;&#09;# Do something right before every call to func&#10;&#09;&#09;&#09;print(f'decorator_args: {args}')&#10;&#09;&#09;&#09;print(f'decorated_args: {a}, {kw}')&#10;&#09;&#09;&#09;return func(*a, **kw)&#10;&#09;&#09;&#09;# Do something right after every call to func&#10;&#09;&#09;return wrapper&#10;&#09;return decorator&#10;&#10;&#10;@get_decorator(&quot;bar&quot;)&#10;def foo(*a, **kw):&#10;&#09;# do something&#10;&#09;pass&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;&#09;foo(&quot;a&quot;, x=&quot;b&quot;)" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twimport" value="sys.path.insert(0, &quot;..&quot;)  # TODO: remove" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="assert" value="assert $param1$, &quot;$param2$&quot;" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="bool expr" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="msg" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="modelinePy" value="# vim: ts=4 sts=4 sw=4 fdl=0" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twBase" value="from twBase import *" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twimage" value="from PIL import Image&#10;img = Image.open($param1$)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="file" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="ry try systemExi" value="try&#10;except IOError, e:&#10;raise SystemExit(&quot;Error: %s&quot; % str(e))" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="embed" value="from IPython import embed&#10;embed()" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="fore" value="for i, v in enumerate($param1$):&#10;&#09;pass" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="string" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="forkv" value="for k, v in $param1$.items():&#10;&#09;pass" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="string" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="timing" value="start = time.time()&#10;print(&quot;$param1$ took {} seconds.&quot;.format(time.time() - start))" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="action" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twenvironment" value="try:&#10;&#09;data_path = os.environ['$param1$']&#10;except KeyError:&#10;&#09;print(&quot;$param1$ is not set.&quot;)&#10;&#09;sys.exit(1)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twNone" value="$param1$ = xxx if $param1$ is None else $param1$" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="var" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twlog" value="import logging&#10;_LOGGER = logging.getLogger(__name__)&#10;handler = logging.StreamHandler(sys.stdout)&#10;handler.setFormatter(logging.Formatter(&#10;&#09;'%(asctime)-15s %(levelname)s %(name)s %(funcName)s:%(lineno)d %(message)s',&#10;&#09;datefmt='%Y-%m-%d %H:%M:%S'))&#10;_LOGGER.addHandler(handler)&#10;_LOGGER.setLevel(logging.DEBUG)" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twlogbasic" value="import logging&#10;_LOGGER = logging.getLogger(__name__)&#10;log_fmt = r'%(asctime)-15s %(levelname)s %(name)s %(funcName)s:%(lineno)d %(message)s'&#10;datefmt='%Y-%m-%d %H:%M:%S'&#10;logging.basicConfig(format=log_fmt, level=logging.DEBUG, datefmt=datefmt)" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="pprint" value="from pprint import pprint  # NOQA" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="structlog" value="import structlog&#10;# structured logging: debug, info, warn err, critical&#10;# log.debug(&quot;debug logg&quot;, stack_info=True)&#10;logging.basicConfig(format=&quot;&quot;, stream=sys.stderr, level=logging.DEBUG)&#10;logcfg(sys.stderr, logging.DEBUG, RenderEnum.console)&#10;log = structlog.get_logger(__name__)" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="&quot;" value="&quot;{0!s}&quot;.format($param1$)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="string" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="dbg" value="import ipdb; ipdb.set_trace()  # NOQA XXX BREAKPOINT" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="dbgp" value="print(&quot;D: {0}: $param1$: {1}&quot;.format(logme(), $param2$))" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="str" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="var" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twplot" value="import numpy as np&#10;import import matplotlib.pyplot as plt&#10;plt.plot(np.linspace(1, 4, 10), np.logspace(1, 4, 10))&#10;plt.show()" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="touch" value="open(file, 'a').close()" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="confload" value="# load config from json if no dict&#10;if isinstance(conf, str):&#10;&#09;conf = json.load(open(conf, 'rb'))" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="copyf" value="import shutil&#10;shutil.copyfile($param1$, $param2$ + $param1$)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="fn" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="path" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="rmdir" value="import shutil&#10;shutil.rmtree($param1$)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="fn" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twmake_dir" value="os.makedirs(_parameter_to_change_, exist_ok=True)" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twtest_file" value="if not os.path.exists($param1$):&#10;&#09;log.error(&quot;-E- model does not exist.&quot;, path=$param1$)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="path" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="walk" value="for folderName, subfolders, filenames in os.walk($param1$):" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="path" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twwrite_text" value="with open($param1$, 'w') as textfile:&#10;&#09;print($param2$, file=textfile)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="path" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="string" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twread_text" value="with open($param1$, 'r') as textfile:&#10;&#09;text = (textfile.read())" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="path" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twjson_save" value="with open($param1$, 'w') as f:&#10;&#09;json.dump($param2$, f)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="fn" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="data" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twjson_read" value="with open($param1$, 'r') as f:&#10;&#09;$param2$ = json.load(f)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="fn" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="data" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twpickle_save_bz2" value="import pickle, gzip, bz2&#10;with bz2.open($param1$, 'wb') as f:&#10;&#09;pickle.dump($param2$, f)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="fn" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="data" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twpickle_read_bz2" value="import pickle, gzip, bz2&#10;with bz2.open($param1$, 'rb') as f:&#10;&#09;$param2$ = pickle.load(f)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="fn" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="data" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twpickle_save" value="with open($param1$, 'wb') as f:&#10;&#09;pickle.dump($param2$, f)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="fn" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="data" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twpickle_read" value="with open($param1$, 'rb') as f:&#10;&#09;$param2$ = pickle.load(f)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="fn" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="data" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twh5_save" value="import h5py&#10;if os.path.exists(h5_file):&#10;&#09;os.remove(h5_file)&#10;&#10;with h5py.File(h5_file, &quot;a&quot;) as f:&#10;#f = h5py.File(h5_file)&#10;&#09;f['y'] = y&#10;#f.close()&#10;log.info(&quot;Saved&quot;, data=h5_file)" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twh5_read" value="import h5py&#10;assert os.path.exists(h5data_fn), &quot;{} does not exist&quot;.format(h5data_fn)&#10;with h5py.File(h5data_fn, &quot;r&quot;) as f:&#10;#f = h5py.File(h5data_fn)&#10;&#09;y = f['y'].value&#10;#f.close()" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twscript" value="@click.group()&#10;@click.option('--debug/--no-debug', default=False)&#10;@click.pass_context&#10;def cli(ctx, debug):&#10;&#09;# ensure that ctx.obj exists and is a dict (in case `cli()` is called&#10;&#09;# by means other than the `if` block below&#10;&#09;ctx.ensure_object(dict)&#10;&#09;ctx.obj['DEBUG'] = debug&#10;&#10;&#10;@click.command()&#10;@click.pass_context&#10;def sync(ctx):&#10;&#09;click.echo('Debug is %s' % (ctx.obj['DEBUG'] and 'on' or 'off'))&#10;&#10;click.add_command(all)&#10;&#10;&#10;if __name__ == '__main__':&#10;&#09;cli(obj={})" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="main_script" value="import fire&#10;import subprocess&#10;&#10;def run(s):&#10;&#09;subprocess.run(s, check=True, shell=True)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;&#09;fire.Fire()" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="main_fire" value="import fire&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;&#09;fire.Fire()" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="main" value="#!/usr/bin/env python3&#10;# -*- coding: utf-8 -*-&#10;&#10;&quot;&quot;&quot;module docstring&quot;&quot;&quot;&#10;&#10;# imports&#10;import sys, os, argparse, logging  # NOQA&#10;from pprint import pprint&#10;from twbase import structlog, logcfg, RenderEnum, twStart, twEnd, read_yaml, Struct&#10;&#10;&#10;def process_command_line(argv):&#10;&#09;# create the top-level parser&#10;&#09;parser = argparse.ArgumentParser(description=&quot;&quot;)&#10;&#09;parser.add_argument(&quot;-d&quot;, &quot;--debug&quot;, help=&quot;print debug messages&quot;, action=&quot;store_true&quot;)&#10;&#09;parser.add_argument(&quot;-c&quot;, &quot;--config&quot;, help=&quot;load config: absolute path&quot;, type=str, default=None)&#10;&#09;args = parser.parse_args(argv)&#10;&#09;return args&#10;&#10;&#10;def main(argv=None):&#10;&#09;args = process_command_line(argv)&#10;&#09;if args.debug:&#10;&#09;&#09;logcfg(sys.stderr, logging.DEBUG, RenderEnum.console)&#10;&#09;else:&#10;&#09;&#09;logcfg(sys.stderr, logging.INFO, RenderEnum.console)&#10;&#09;# logging.getLogger().setLevel(logging.INFO)&#10;&#09;log = structlog.get_logger(__name__)&#10;&#09;twStart()&#10;&#10;&#09;log.debug(&quot;Loading yaml&quot;, cfg=args.config)&#10;&#09;config = read_yaml(args.config)&#10;&#09;config = Struct({**config, **vars(args)})  # dict not working&#10;&#09;pprint(config)&#10;&#10;&#09;twEnd()&#10;&#09;return 0  # success&#10;&#10;&#10;if __name__ == '__main__':&#10;&#09;sys.exit(main(sys.argv[1:]))" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twargparse" value="def process_command_line(argv):&#10;&#09;#args = process_command_line(argv)&#10;&#09;parser = argparse.ArgumentParser(description=&quot;xx&quot;)&#10;&#10;&#09;parser.add_argument(&quot;-s&quot;, &quot;--sample&quot;, help=&quot;xx&quot;, action=&quot;store_true&quot;)&#10;&#09;parser.add_argument(&quot;-l&quot;, &quot;--load&quot;, help=&quot;xx&quot;, type=str, default=None)&#10;&#10;&#09;args = parser.parse_args(argv)&#10;&#09;return args" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="config" value="class Config(object):&#10;&#10;&#09;&quot;&quot;&quot;&#10;&#09;def process_command_line(argv):&#10;&#09;&#09;parser = argparse.ArgumentParser(description=&quot;programpurpose&quot;)&#10;&#09;&#09;parser.add_argument(&quot;-s&quot;, &quot;--sample&quot;, help=&quot;use only sample subset&quot;, action=&quot;store_true&quot;)&#10;&#09;&#09;parser.add_argument(&quot;-b&quot;, &quot;--batch_size&quot;, help=&quot;batch size&quot;, type=int)&#10;&#09;&#09;parser.add_argument(&quot;-c&quot;, &quot;--load_config&quot;, help=&quot;load config: absolute path&quot;, type=str, default=None)&#10;&#09;&#09;args = parser.parse_args(argv)&#10;&#09;&#09;return args&#10;&#09;args = process_command_line(argv)&#10;&#09;P = Config()(args)&#10;&#09;&quot;&quot;&quot;&#10;&#10;&#09;def __init__(self):&#10;&#09;&#09;pass&#10;&#10;&#09;def __call__(self, args):&#10;&#09;&#09;if args.load_config is not None:&#10;&#09;&#09;&#09;return self.load_config(args.load_config)&#10;&#09;&#09;else:&#10;&#09;&#09;&#09;return self.get_parameters(args)&#10;&#10;&#09;def get_parameters(self, args):&#10;&#09;&#09;'''&#10;&#09;&#09;derived parameters are defined in params, but with value None. Will be set after instantiation of dict&#10;&#09;&#09;args: will be set ONLY by command line args&#10;&#09;&#09;args can be overwritten by cmdline args, but ther must be no default value in argsparse&#10;&#09;&#09;'''&#10;&#09;&#09;params = {&#10;&#09;&#09;&#09;&quot;DATA&quot;: {&#10;&#09;&#09;&#09;&#09;&quot;BASE_DIR&quot;: &quot;./data&quot;,&#10;&#09;&#09;&#09;&#09;&quot;DATA_FN&quot;: './data/Lastprognose/2015.csv',&#10;&#09;&#09;&#09;&#09;&quot;isSample&quot;: False,&#10;&#09;&#09;&#09;},&#10;&#09;&#09;&#09;&quot;MODEL&quot;: {&#10;&#09;&#09;&#09;&#09;&quot;SUFFIX&quot;: &quot;xxx&quot;,&#10;&#09;&#09;&#09;&#09;&quot;NAME&quot;: None,&#10;&#09;&#09;&#09;&#09;&quot;CLASS&quot;: &quot;RNN1&quot;,&#10;&#09;&#09;&#09;},&#10;&#09;&#09;&#09;&quot;TRAINING&quot;: {},&#10;&#09;&#09;&#09;&quot;OUTPUT&quot;: {&#10;&#09;&#09;&#09;&#09;&quot;BASE_DIR&quot;: &quot;./data/out&quot;,&#10;&#09;&#09;&#09;&#09;&quot;MODEL_DIR&quot;: None,&#10;&#09;&#09;&#09;}&#10;&#09;&#09;}&#10;&#10;&#09;&#09;P = Struct(params)&#10;&#09;&#09;P.MODEL.NAME = &quot;{}.{}&quot;.format(P.MODEL.CLASS, P.MODEL.SUFFIX)  # build name&#10;&#09;&#09;P.OUTPUT.MODEL_DIR = os.path.join(P.OUTPUT.BASE_DIR, P.MODEL.NAME)  # build output dir&#10;&#10;&#09;&#09;### Overwrite conf with cmdline params&#10;&#09;&#09;# for overwriting must not have default in argsparse, otherwise default will overwrite&#10;&#09;&#09;# adding parameters only works when dict struct is already created&#10;&#09;&#09;if hasattr(args, 'epoch'):&#10;&#09;&#09;&#09;if args.epoch is not None:&#10;&#09;&#09;&#09;&#09;P.TRAINING.EPOCHS = args.epoch&#10;&#10;&#09;&#09;if hasattr(args, 'batch_size'):&#10;&#09;&#09;&#09;if args.batch_size is not None:&#10;&#09;&#09;&#09;&#09;P.TRAINING.BATCH_SIZE = args.batch_size&#10;&#10;&#09;&#09;if args.sample:&#10;&#09;&#09;&#09;P.DATA.isSample = args.sample&#10;&#10;&#09;&#09;os.makedirs(P.OUTPUT.MODEL_DIR, exist_ok=True)&#10;&#09;&#09;with open(os.path.join(P.OUTPUT.MODEL_DIR, 'config.json'), 'w') as f:&#10;&#09;&#09;&#09;json.dump(P, f, default=twSerialize, indent=4)&#10;&#10;&#09;&#09;return P&#10;&#10;&#10;&#09;def load_config(self, path):&#10;&#09;&#09;assert os.path.exists(path), &quot;{} does not exist&quot;.format(path)&#10;&#09;&#09;log.info(&quot;Loading config&quot;, c=path)&#10;&#09;&#09;with open(path, 'r') as f:&#10;&#09;&#09;&#09;return Struct(json.load(f))" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twclass" value="class MyClass(object):&#10;&#09;&quot;&quot;&quot;Docstring for MyClass. &quot;&quot;&quot;&#10;&#10;&#09;@classmethod  # classmethod always gets class as parameter&#10;&#09;def get_clsname(cls):&#10;&#09;&#09;return cls.__name__&#10;&#10;&#09;def __init__(self):&#10;&#09;&#09;super().__init__()&#10;&#10;&#09;def __repr__(self):&#10;&#09;&#09;return &quot;{self.__class__.__name__}&quot;  # subclassing!&#10;&#10;&#09;def save(self, filename: Union[str, PathLike], prop: str = None):&#10;&#09;&#09;with open(filename, 'wb') as f:&#10;&#09;&#09;&#09;if prop is None:&#10;&#09;&#09;&#09;&#09;_log.info(f&quot;Saving {self.__class__.__name__} to {f}.&quot;)&#10;&#09;&#09;&#09;&#09;pickle.dump(self, f)&#10;&#09;&#09;&#09;&#09;return&#10;&#09;&#09;&#09;if prop in self.__dict__.keys():&#10;&#09;&#09;&#09;&#09;_log.info(f&quot;Saving {prop}.&quot;)&#10;&#09;&#09;&#09;&#09;data = getattr(self, prop)&#10;&#09;&#09;&#09;&#09;pickle.dump(data, f)&#10;&#09;&#09;&#09;else:&#10;&#09;&#09;&#09;&#09;_log.warning(f&quot;{prop} does not exist on {self.__class__.__name__}.&quot;)&#10;&#10;&#09;@staticmethod&#10;&#09;def load(filename: PathLike) -&gt; 'Config':&#10;&#09;&#09;_log.info(f'Loading instance: {filename}')&#10;&#09;&#09;with open(filename, 'rb') as f:&#10;&#09;&#09;&#09;return pickle.load(f)" description="" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twtest" value="import unittest&#10;from $param1$ import $param1$&#10;&#10;'''&#10;python xxx.test.py -v&#10;python xxx.test.py -v TestReverseDiff.test_combine_XY&#10;python -m unittest tests.test_schedule.TestSchedule.test__check_periodicity -v&#10;'''&#10;&#10;class Test_$param2$(unittest.TestCase):&#10;&#09;'''&#10;&#09;python -m unittest twbase.test.test_Struct.Test_$param2$ -v&#10;&#09;'''&#10;&#10;&#09;def setUp(self):&#10;&#09;&#09;'''will be called for every test'''&#10;&#09;&#09;if ('-v' in sys.argv):&#10;&#09;&#09;&#09;_LOGGER.setLevel(logging.DEBUG)&#10;&#10;&#09;def test_get_sin(self):&#10;&#09;&#09;self.assertEqual(4, 4)&#10;&#10;&#09;def test__check_periodicity(self):&#10;&#09;&#09;schedule = [1, 2, 3]&#10;&#09;&#09;with self.assertRaises(AssertionError):&#10;&#09;&#09;&#09;s = Schedule(schedule)&#10;&#10;&#10;if __name__ == '__main__':&#10;&#09;unittest.main()" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="param2" expression="" defaultValue="testclass" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
  <template name="twtestclass" value="class Test_$param1$(unittest.TestCase):&#10;&#10;&#09;def setUp(self):&#10;&#09;&#09;'''will be called for every test'''&#10;&#09;&#09;self.fixture = 'xxx'&#10;&#10;&#09;def test_xxx(self):&#10;&#09;&#09;self.assertEqual(bla(), 10)" description="" toReformat="true" toShortenFQNames="true">
    <variable name="param1" expression="" defaultValue="name" alwaysStopAt="true" />
    <context>
      <option name="Python" value="true" />
    </context>
  </template>
</templateSet>